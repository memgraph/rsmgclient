// Copyright (c) 2016-2020 Memgraph Ltd. [https://memgraph.com]
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* automatically generated by rust-bindgen 0.54.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 29;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const MG_MAX_ERROR_SIZE: u32 = 1024;
pub const MG_SESSION_READY: u32 = 0;
pub const MG_SESSION_EXECUTING: u32 = 1;
pub const MG_SESSION_BAD: u32 = 2;
pub const MG_ERROR_SEND_FAILED: i32 = -1;
pub const MG_ERROR_RECV_FAILED: i32 = -2;
pub const MG_ERROR_OOM: i32 = -3;
pub const MG_ERROR_CONTAINER_FULL: i32 = -4;
pub const MG_ERROR_INVALID_VALUE: i32 = -5;
pub const MG_ERROR_DECODING_FAILED: i32 = -6;
pub const MG_ERROR_DUPLICATE_KEY: i32 = -7;
pub const MG_ERROR_NETWORK_FAILURE: i32 = -8;
pub const MG_ERROR_BAD_PARAMETER: i32 = -9;
pub const MG_ERROR_PROTOCOL_VIOLATION: i32 = -10;
pub const MG_ERROR_CLIENT_ERROR: i32 = -11;
pub const MG_ERROR_TRANSIENT_ERROR: i32 = -12;
pub const MG_ERROR_DATABASE_ERROR: i32 = -13;
pub const MG_ERROR_UNKNOWN_ERROR: i32 = -14;
pub const MG_ERROR_BAD_CALL: i32 = -15;
pub const MG_ERROR_SIZE_EXCEEDED: i32 = -16;
pub const MG_ERROR_SSL_ERROR: i32 = -17;
pub const MG_ERROR_TRUST_CALLBACK: i32 = -18;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub const mg_value_type_MG_VALUE_TYPE_NULL: mg_value_type = 0;
pub const mg_value_type_MG_VALUE_TYPE_BOOL: mg_value_type = 1;
pub const mg_value_type_MG_VALUE_TYPE_INTEGER: mg_value_type = 2;
pub const mg_value_type_MG_VALUE_TYPE_FLOAT: mg_value_type = 3;
pub const mg_value_type_MG_VALUE_TYPE_STRING: mg_value_type = 4;
pub const mg_value_type_MG_VALUE_TYPE_LIST: mg_value_type = 5;
pub const mg_value_type_MG_VALUE_TYPE_MAP: mg_value_type = 6;
pub const mg_value_type_MG_VALUE_TYPE_NODE: mg_value_type = 7;
pub const mg_value_type_MG_VALUE_TYPE_RELATIONSHIP: mg_value_type = 8;
pub const mg_value_type_MG_VALUE_TYPE_UNBOUND_RELATIONSHIP: mg_value_type = 9;
pub const mg_value_type_MG_VALUE_TYPE_PATH: mg_value_type = 10;
pub const mg_value_type_MG_VALUE_TYPE_UNKNOWN: mg_value_type = 11;
pub type mg_value_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_string {
    pub size: u32,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mg_string() {
    assert_eq!(
        ::std::mem::size_of::<mg_string>(),
        16usize,
        concat!("Size of: ", stringify!(mg_string))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_string>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_string))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_string>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_string),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_string>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_string),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_list {
    pub size: u32,
    pub capacity: u32,
    pub elements: *mut *mut mg_value,
}
#[test]
fn bindgen_test_layout_mg_list() {
    assert_eq!(
        ::std::mem::size_of::<mg_list>(),
        16usize,
        concat!("Size of: ", stringify!(mg_list))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_list>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_list>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_list),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_list>())).capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_list),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_list>())).elements as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_list),
            "::",
            stringify!(elements)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_map {
    pub size: u32,
    pub capacity: u32,
    pub keys: *mut *mut mg_string,
    pub values: *mut *mut mg_value,
}
#[test]
fn bindgen_test_layout_mg_map() {
    assert_eq!(
        ::std::mem::size_of::<mg_map>(),
        24usize,
        concat!("Size of: ", stringify!(mg_map))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_map>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_map>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_map),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_map>())).capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_map),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_map>())).keys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_map),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_map>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_map),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_node {
    pub id: i64,
    pub label_count: u32,
    pub labels: *mut *mut mg_string,
    pub properties: *mut mg_map,
}
#[test]
fn bindgen_test_layout_mg_node() {
    assert_eq!(
        ::std::mem::size_of::<mg_node>(),
        32usize,
        concat!("Size of: ", stringify!(mg_node))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_node>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_node>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_node),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_node>())).label_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_node),
            "::",
            stringify!(label_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_node>())).labels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_node),
            "::",
            stringify!(labels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_node>())).properties as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_node),
            "::",
            stringify!(properties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_relationship {
    pub id: i64,
    pub start_id: i64,
    pub end_id: i64,
    pub type_: *mut mg_string,
    pub properties: *mut mg_map,
}
#[test]
fn bindgen_test_layout_mg_relationship() {
    assert_eq!(
        ::std::mem::size_of::<mg_relationship>(),
        40usize,
        concat!("Size of: ", stringify!(mg_relationship))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_relationship>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_relationship))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_relationship>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_relationship),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_relationship>())).start_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_relationship),
            "::",
            stringify!(start_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_relationship>())).end_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_relationship),
            "::",
            stringify!(end_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_relationship>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_relationship),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_relationship>())).properties as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_relationship),
            "::",
            stringify!(properties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_unbound_relationship {
    pub id: i64,
    pub type_: *mut mg_string,
    pub properties: *mut mg_map,
}
#[test]
fn bindgen_test_layout_mg_unbound_relationship() {
    assert_eq!(
        ::std::mem::size_of::<mg_unbound_relationship>(),
        24usize,
        concat!("Size of: ", stringify!(mg_unbound_relationship))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_unbound_relationship>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_unbound_relationship))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_unbound_relationship>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_unbound_relationship),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_unbound_relationship>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_unbound_relationship),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_unbound_relationship>())).properties as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_unbound_relationship),
            "::",
            stringify!(properties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_path {
    pub node_count: u32,
    pub relationship_count: u32,
    pub sequence_length: u32,
    pub nodes: *mut *mut mg_node,
    pub relationships: *mut *mut mg_unbound_relationship,
    pub sequence: *mut i64,
}
#[test]
fn bindgen_test_layout_mg_path() {
    assert_eq!(
        ::std::mem::size_of::<mg_path>(),
        40usize,
        concat!("Size of: ", stringify!(mg_path))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_path>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_path))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_path>())).node_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_path),
            "::",
            stringify!(node_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_path>())).relationship_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_path),
            "::",
            stringify!(relationship_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_path>())).sequence_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_path),
            "::",
            stringify!(sequence_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_path>())).nodes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_path),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_path>())).relationships as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_path),
            "::",
            stringify!(relationships)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_path>())).sequence as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_path),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mg_value {
    pub type_: mg_value_type,
    pub __bindgen_anon_1: mg_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mg_value__bindgen_ty_1 {
    pub bool_v: ::std::os::raw::c_int,
    pub integer_v: i64,
    pub float_v: f64,
    pub string_v: *mut mg_string,
    pub list_v: *mut mg_list,
    pub map_v: *mut mg_map,
    pub node_v: *mut mg_node,
    pub relationship_v: *mut mg_relationship,
    pub unbound_relationship_v: *mut mg_unbound_relationship,
    pub path_v: *mut mg_path,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_mg_value__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mg_value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mg_value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).bool_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(bool_v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).integer_v as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(integer_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).float_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(float_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).string_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(string_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).list_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(list_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).map_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(map_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).node_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(node_v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).relationship_v as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(relationship_v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).unbound_relationship_v as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(unbound_relationship_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value__bindgen_ty_1>())).path_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value__bindgen_ty_1),
            "::",
            stringify!(path_v)
        )
    );
}
#[test]
fn bindgen_test_layout_mg_value() {
    assert_eq!(
        ::std::mem::size_of::<mg_value>(),
        16usize,
        concat!("Size of: ", stringify!(mg_value))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_value>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_value>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_value),
            "::",
            stringify!(type_)
        )
    );
}
pub const mg_message_type_MG_MESSAGE_TYPE_RECORD: mg_message_type = 0;
pub const mg_message_type_MG_MESSAGE_TYPE_SUCCESS: mg_message_type = 1;
pub const mg_message_type_MG_MESSAGE_TYPE_FAILURE: mg_message_type = 2;
pub const mg_message_type_MG_MESSAGE_TYPE_INIT: mg_message_type = 3;
pub const mg_message_type_MG_MESSAGE_TYPE_RUN: mg_message_type = 4;
pub const mg_message_type_MG_MESSAGE_TYPE_ACK_FAILURE: mg_message_type = 5;
pub const mg_message_type_MG_MESSAGE_TYPE_PULL_ALL: mg_message_type = 6;
pub type mg_message_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_message_success {
    pub metadata: *mut mg_map,
}
#[test]
fn bindgen_test_layout_mg_message_success() {
    assert_eq!(
        ::std::mem::size_of::<mg_message_success>(),
        8usize,
        concat!("Size of: ", stringify!(mg_message_success))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_message_success>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_message_success))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message_success>())).metadata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message_success),
            "::",
            stringify!(metadata)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_message_failure {
    pub metadata: *mut mg_map,
}
#[test]
fn bindgen_test_layout_mg_message_failure() {
    assert_eq!(
        ::std::mem::size_of::<mg_message_failure>(),
        8usize,
        concat!("Size of: ", stringify!(mg_message_failure))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_message_failure>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_message_failure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message_failure>())).metadata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message_failure),
            "::",
            stringify!(metadata)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_message_record {
    pub fields: *mut mg_list,
}
#[test]
fn bindgen_test_layout_mg_message_record() {
    assert_eq!(
        ::std::mem::size_of::<mg_message_record>(),
        8usize,
        concat!("Size of: ", stringify!(mg_message_record))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_message_record>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_message_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message_record>())).fields as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message_record),
            "::",
            stringify!(fields)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_message_init {
    pub client_name: *mut mg_string,
    pub auth_token: *mut mg_map,
}
#[test]
fn bindgen_test_layout_mg_message_init() {
    assert_eq!(
        ::std::mem::size_of::<mg_message_init>(),
        16usize,
        concat!("Size of: ", stringify!(mg_message_init))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_message_init>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_message_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message_init>())).client_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message_init),
            "::",
            stringify!(client_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message_init>())).auth_token as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message_init),
            "::",
            stringify!(auth_token)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_message_run {
    pub statement: *mut mg_string,
    pub parameters: *mut mg_map,
}
#[test]
fn bindgen_test_layout_mg_message_run() {
    assert_eq!(
        ::std::mem::size_of::<mg_message_run>(),
        16usize,
        concat!("Size of: ", stringify!(mg_message_run))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_message_run>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_message_run))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message_run>())).statement as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message_run),
            "::",
            stringify!(statement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message_run>())).parameters as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message_run),
            "::",
            stringify!(parameters)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mg_message {
    pub type_: mg_message_type,
    pub __bindgen_anon_1: mg_message__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mg_message__bindgen_ty_1 {
    pub success_v: *mut mg_message_success,
    pub failure_v: *mut mg_message_failure,
    pub record_v: *mut mg_message_record,
    pub init_v: *mut mg_message_init,
    pub run_v: *mut mg_message_run,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_mg_message__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mg_message__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mg_message__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_message__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_message__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_message__bindgen_ty_1>())).success_v as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message__bindgen_ty_1),
            "::",
            stringify!(success_v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_message__bindgen_ty_1>())).failure_v as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message__bindgen_ty_1),
            "::",
            stringify!(failure_v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_message__bindgen_ty_1>())).record_v as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message__bindgen_ty_1),
            "::",
            stringify!(record_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message__bindgen_ty_1>())).init_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message__bindgen_ty_1),
            "::",
            stringify!(init_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message__bindgen_ty_1>())).run_v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message__bindgen_ty_1),
            "::",
            stringify!(run_v)
        )
    );
}
#[test]
fn bindgen_test_layout_mg_message() {
    assert_eq!(
        ::std::mem::size_of::<mg_message>(),
        16usize,
        concat!("Size of: ", stringify!(mg_message))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_message>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_message>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_message),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    pub fn mg_value_make_null() -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_bool(val: ::std::os::raw::c_int) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_integer(val: i64) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_float(val: f64) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_string(str_: *const ::std::os::raw::c_char) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_string2(str_: *mut mg_string) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_list(list: *mut mg_list) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_map(map: *mut mg_map) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_node(node: *mut mg_node) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_relationship(rel: *mut mg_relationship) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_unbound_relationship(rel: *mut mg_unbound_relationship) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_make_path(path: *mut mg_path) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_get_type(val: *const mg_value) -> mg_value_type;
}
extern "C" {
    pub fn mg_value_bool(val: *const mg_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_value_integer(val: *const mg_value) -> i64;
}
extern "C" {
    pub fn mg_value_float(val: *const mg_value) -> f64;
}
extern "C" {
    pub fn mg_value_string(val: *const mg_value) -> *const mg_string;
}
extern "C" {
    pub fn mg_value_list(val: *const mg_value) -> *const mg_list;
}
extern "C" {
    pub fn mg_value_map(val: *const mg_value) -> *const mg_map;
}
extern "C" {
    pub fn mg_value_node(val: *const mg_value) -> *const mg_node;
}
extern "C" {
    pub fn mg_value_relationship(val: *const mg_value) -> *const mg_relationship;
}
extern "C" {
    pub fn mg_value_unbound_relationship(val: *const mg_value) -> *const mg_unbound_relationship;
}
extern "C" {
    pub fn mg_value_path(val: *const mg_value) -> *const mg_path;
}
extern "C" {
    pub fn mg_value_copy(val: *const mg_value) -> *mut mg_value;
}
extern "C" {
    pub fn mg_value_destroy(val: *mut mg_value);
}
extern "C" {
    pub fn mg_string_make(str_: *const ::std::os::raw::c_char) -> *mut mg_string;
}
extern "C" {
    pub fn mg_string_make2(len: u32, data: *const ::std::os::raw::c_char) -> *mut mg_string;
}
extern "C" {
    pub fn mg_string_data(str_: *const mg_string) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_string_size(str_: *const mg_string) -> u32;
}
extern "C" {
    pub fn mg_string_copy(str_: *const mg_string) -> *mut mg_string;
}
extern "C" {
    pub fn mg_string_destroy(str_: *mut mg_string);
}
extern "C" {
    pub fn mg_list_make_empty(capacity: u32) -> *mut mg_list;
}
extern "C" {
    pub fn mg_list_append(list: *mut mg_list, value: *mut mg_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_list_size(list: *const mg_list) -> u32;
}
extern "C" {
    pub fn mg_list_at(list: *const mg_list, pos: u32) -> *const mg_value;
}
extern "C" {
    pub fn mg_list_copy(list: *const mg_list) -> *mut mg_list;
}
extern "C" {
    pub fn mg_list_destroy(list: *mut mg_list);
}
extern "C" {
    pub fn mg_map_make_empty(capacity: u32) -> *mut mg_map;
}
extern "C" {
    pub fn mg_map_insert(
        map: *mut mg_map,
        key_str: *const ::std::os::raw::c_char,
        value: *mut mg_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_map_insert2(
        map: *mut mg_map,
        key: *mut mg_string,
        value: *mut mg_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_map_insert_unsafe(
        map: *mut mg_map,
        key_str: *const ::std::os::raw::c_char,
        value: *mut mg_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_map_insert_unsafe2(
        map: *mut mg_map,
        key: *mut mg_string,
        value: *mut mg_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_map_at(map: *const mg_map, key_str: *const ::std::os::raw::c_char)
        -> *const mg_value;
}
extern "C" {
    pub fn mg_map_at2(
        map: *const mg_map,
        key_size: u32,
        key_data: *const ::std::os::raw::c_char,
    ) -> *const mg_value;
}
extern "C" {
    pub fn mg_map_size(map: *const mg_map) -> u32;
}
extern "C" {
    pub fn mg_map_key_at(arg1: *const mg_map, pos: u32) -> *const mg_string;
}
extern "C" {
    pub fn mg_map_value_at(arg1: *const mg_map, pos: u32) -> *const mg_value;
}
extern "C" {
    pub fn mg_map_copy(map: *const mg_map) -> *mut mg_map;
}
extern "C" {
    pub fn mg_map_destroy(map: *mut mg_map);
}
extern "C" {
    pub fn mg_node_id(node: *const mg_node) -> i64;
}
extern "C" {
    pub fn mg_node_label_count(node: *const mg_node) -> u32;
}
extern "C" {
    pub fn mg_node_label_at(node: *const mg_node, pos: u32) -> *const mg_string;
}
extern "C" {
    pub fn mg_node_properties(node: *const mg_node) -> *const mg_map;
}
extern "C" {
    pub fn mg_node_copy(node: *const mg_node) -> *mut mg_node;
}
extern "C" {
    pub fn mg_node_destroy(node: *mut mg_node);
}
extern "C" {
    pub fn mg_relationship_id(rel: *const mg_relationship) -> i64;
}
extern "C" {
    pub fn mg_relationship_start_id(rel: *const mg_relationship) -> i64;
}
extern "C" {
    pub fn mg_relationship_end_id(rel: *const mg_relationship) -> i64;
}
extern "C" {
    pub fn mg_relationship_type(rel: *const mg_relationship) -> *const mg_string;
}
extern "C" {
    pub fn mg_relationship_properties(rel: *const mg_relationship) -> *const mg_map;
}
extern "C" {
    pub fn mg_relationship_copy(rel: *const mg_relationship) -> *mut mg_relationship;
}
extern "C" {
    pub fn mg_relationship_destroy(rel: *mut mg_relationship);
}
extern "C" {
    pub fn mg_unbound_relationship_id(rel: *const mg_unbound_relationship) -> i64;
}
extern "C" {
    pub fn mg_unbound_relationship_type(rel: *const mg_unbound_relationship) -> *const mg_string;
}
extern "C" {
    pub fn mg_unbound_relationship_properties(rel: *const mg_unbound_relationship)
        -> *const mg_map;
}
extern "C" {
    pub fn mg_unbound_relationship_copy(
        rel: *const mg_unbound_relationship,
    ) -> *mut mg_unbound_relationship;
}
extern "C" {
    pub fn mg_unbound_relationship_destroy(rel: *mut mg_unbound_relationship);
}
extern "C" {
    pub fn mg_path_length(path: *const mg_path) -> u32;
}
extern "C" {
    pub fn mg_path_node_at(path: *const mg_path, pos: u32) -> *const mg_node;
}
extern "C" {
    pub fn mg_path_relationship_at(
        path: *const mg_path,
        pos: u32,
    ) -> *const mg_unbound_relationship;
}
extern "C" {
    pub fn mg_path_relationship_reversed_at(
        path: *const mg_path,
        pos: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_path_copy(path: *const mg_path) -> *mut mg_path;
}
extern "C" {
    pub fn mg_path_destroy(path: *mut mg_path);
}
pub const mg_sslmode_MG_SSLMODE_DISABLE: mg_sslmode = 0;
pub const mg_sslmode_MG_SSLMODE_REQUIRE: mg_sslmode = 1;
pub type mg_sslmode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_transport {
    pub send: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mg_transport,
            buf: *const ::std::os::raw::c_char,
            len: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub recv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mg_transport,
            buf: *mut ::std::os::raw::c_char,
            len: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut mg_transport)>,
}
#[test]
fn bindgen_test_layout_mg_transport() {
    assert_eq!(
        ::std::mem::size_of::<mg_transport>(),
        24usize,
        concat!("Size of: ", stringify!(mg_transport))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_transport>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_transport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_transport>())).send as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_transport),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_transport>())).recv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_transport),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_transport>())).destroy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_transport),
            "::",
            stringify!(destroy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_allocator {
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut mg_allocator, size: size_t) -> *mut ::std::os::raw::c_void,
    >,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut mg_allocator,
            buf: *mut ::std::os::raw::c_void,
            size: size_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut mg_allocator, buf: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_mg_allocator() {
    assert_eq!(
        ::std::mem::size_of::<mg_allocator>(),
        24usize,
        concat!("Size of: ", stringify!(mg_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_allocator>())).malloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_allocator),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_allocator>())).realloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_allocator),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_allocator>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_allocator),
            "::",
            stringify!(free)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_result {
    pub status: ::std::os::raw::c_int,
    pub session: *mut mg_session,
    pub message: *mut mg_message,
    pub columns: *mut mg_list,
}
#[test]
fn bindgen_test_layout_mg_result() {
    assert_eq!(
        ::std::mem::size_of::<mg_result>(),
        32usize,
        concat!("Size of: ", stringify!(mg_result))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_result>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_result>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_result),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_result>())).session as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_result),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_result>())).message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_result),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_result>())).columns as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_result),
            "::",
            stringify!(columns)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mg_session {
    pub status: ::std::os::raw::c_int,
    pub transport: *mut mg_transport,
    pub out_buffer: *mut ::std::os::raw::c_char,
    pub out_begin: size_t,
    pub out_end: size_t,
    pub out_capacity: size_t,
    pub in_buffer: *mut ::std::os::raw::c_char,
    pub in_end: size_t,
    pub in_capacity: size_t,
    pub in_cursor: size_t,
    pub result: mg_result,
    pub error_buffer: [::std::os::raw::c_char; 1024usize],
    pub allocator: *mut mg_allocator,
    pub decoder_allocator: *mut mg_allocator,
}
#[test]
fn bindgen_test_layout_mg_session() {
    assert_eq!(
        ::std::mem::size_of::<mg_session>(),
        1152usize,
        concat!("Size of: ", stringify!(mg_session))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_session>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_session))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).transport as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).out_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(out_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).out_begin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(out_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).out_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(out_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).out_capacity as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(out_capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).in_buffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(in_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).in_end as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(in_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).in_capacity as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(in_capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).in_cursor as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(in_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).result as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).error_buffer as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(error_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).allocator as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session>())).decoder_allocator as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session),
            "::",
            stringify!(decoder_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mg_session_params {
    pub address: *const ::std::os::raw::c_char,
    pub host: *const ::std::os::raw::c_char,
    pub port: u16,
    pub username: *const ::std::os::raw::c_char,
    pub password: *const ::std::os::raw::c_char,
    pub client_name: *const ::std::os::raw::c_char,
    pub sslmode: mg_sslmode,
    pub sslcert: *const ::std::os::raw::c_char,
    pub sslkey: *const ::std::os::raw::c_char,
    pub trust_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub trust_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mg_session_params() {
    assert_eq!(
        ::std::mem::size_of::<mg_session_params>(),
        88usize,
        concat!("Size of: ", stringify!(mg_session_params))
    );
    assert_eq!(
        ::std::mem::align_of::<mg_session_params>(),
        8usize,
        concat!("Alignment of ", stringify!(mg_session_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).host as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).username as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).password as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).client_name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(client_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).sslmode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(sslmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).sslcert as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(sslcert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).sslkey as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(sslkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mg_session_params>())).trust_callback as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(trust_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mg_session_params>())).trust_data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mg_session_params),
            "::",
            stringify!(trust_data)
        )
    );
}
pub type mg_trust_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;

use mockall::automock;
#[automock(mod mock_params_make;)]
extern "C" {
    pub fn mg_session_params_make() -> *mut mg_session_params;
}
extern "C" {
    pub fn mg_session_params_destroy(arg1: *mut mg_session_params);
}
extern "C" {
    pub fn mg_session_params_set_address(
        arg1: *mut mg_session_params,
        address: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mg_session_params_set_host(
        arg1: *mut mg_session_params,
        host: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mg_session_params_set_port(arg1: *mut mg_session_params, port: u16);
}
extern "C" {
    pub fn mg_session_params_set_username(
        arg1: *mut mg_session_params,
        username: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mg_session_params_set_password(
        arg1: *mut mg_session_params,
        password: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mg_session_params_set_client_name(
        arg1: *mut mg_session_params,
        client_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mg_session_params_set_sslmode(arg1: *mut mg_session_params, sslmode: mg_sslmode);
}
extern "C" {
    pub fn mg_session_params_set_sslcert(
        arg1: *mut mg_session_params,
        sslcert: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mg_session_params_set_sslkey(
        arg1: *mut mg_session_params,
        sslkey: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mg_session_params_set_trust_callback(
        arg1: *mut mg_session_params,
        trust_callback: mg_trust_callback_type,
    );
}
extern "C" {
    pub fn mg_session_params_set_trust_data(
        arg1: *mut mg_session_params,
        trust_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn mg_session_params_get_address(
        arg1: *const mg_session_params,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_params_get_host(
        arg1: *const mg_session_params,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_params_get_port(arg1: *const mg_session_params) -> u16;
}
extern "C" {
    pub fn mg_session_params_get_username(
        arg1: *const mg_session_params,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_params_get_password(
        arg1: *const mg_session_params,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_params_get_client_name(
        arg1: *const mg_session_params,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_params_get_sslmode(arg1: *const mg_session_params) -> mg_sslmode;
}
extern "C" {
    pub fn mg_session_params_get_sslcert(
        arg1: *const mg_session_params,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_params_get_sslkey(
        arg1: *const mg_session_params,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_params_get_trust_callback(
        params: *const mg_session_params,
    ) -> mg_trust_callback_type;
}
extern "C" {
    pub fn mg_session_params_get_trust_data(
        arg1: *const mg_session_params,
    ) -> *mut ::std::os::raw::c_void;
}

#[automock(mod mock_connect;)]
extern "C" {
    pub fn mg_connect(
        params: *const mg_session_params,
        session: *mut *mut mg_session,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_session_status(session: *const mg_session) -> ::std::os::raw::c_int;
}
#[automock(mod mock_mg_session_error;)]
extern "C" {
    pub fn mg_session_error(session: *mut mg_session) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mg_session_destroy(session: *mut mg_session);
}

#[automock(mod mock_run;)]
extern "C" {
    pub fn mg_session_run(
        session: *mut mg_session,
        query: *const ::std::os::raw::c_char,
        params: *const mg_map,
        columns: *mut *const mg_list,
    ) -> ::std::os::raw::c_int;
}
#[automock(mod mock_pull;)]
extern "C" {
    pub fn mg_session_pull(
        session: *mut mg_session,
        result: *mut *mut mg_result,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mg_result_columns(result: *const mg_result) -> *const mg_list;
}
#[automock(mod mock_mg_result_row;)]
extern "C" {
    pub fn mg_result_row(result: *const mg_result) -> *const mg_list;
}
extern "C" {
    pub fn mg_result_summary(result: *const mg_result) -> *const mg_map;
}
